Component:
-----------------------------------------
folder // add a new folder
----
/server

.html
----

.ts
----
import { Component } from '@angular/core';

@Component({
    selector: 'app-server',
    templateUrl: './server.component.html'
})

export class ServerComponent {
}

app.module.ts // add the component in the module
----
import { ServerComponent } from './server/server.component'; // add new import

@NgModule({
    declarations: [
        AppComponent,
        ServerComponent // declare new component
    ],
    // ...
})

app.component.html
----
<serverComponent></serverComponent> // then use like html element 


Data Binding:
-----------------------------------------
1. String interpolation
    <p>{{ displayText }}</p>
2. Property binding
    <button [disabled]="buttonStatus"></button>
3. Event binding
    <button (click)="onCreateNew()"></button>
4. Two-way data binding
    <input [(ngModel)]="productName"></input>


Component Property Binding:
-----------------------------------------
Host component:
----
.html:
<child-component *ngFor="let item of collection"  [childElement]="item"></child-component>

Child component:
----
.html:
<p>{{ element.name }}</p>

.ts:
import { ..., Input } from '@angular/core';

export class ChildComponent {
    @Input('childElement') element: { name: string };  // childElement is an alias and therefore is optional
}


Component Event Binding:
-----------------------------------------
Emittant component:
----
.html:
<input (click)="buttonClicked()">

.ts:
import { ..., EventEmitter, Output } from '@angular/core';

export class child {
    @Output(newItemCreated) itemCreated = new EventEmitter<{ name: string }>();  // newItemCreated is an alias and therefore is optional

    buttonClicked() {
        this.itemCreated.emit({ name: this.name });
    }
}

Listener component:
----
.html:
<child-element (newItemCreated)="onItemAdded($event)"></child-element>

.ts:
onItemAdded(itemData: { name: string }) {
    this.items.push({ name:  itemData.name });
}



Directives:
-----------------------------------------
Structural Directives: (add or remove element)
-----
*ngIf:   // * is needed for structural directives
<p *ngIf="serverCreated; else noServer">Server created</p>
<ng-template #noServer>
    <p>No server created!</p>
</ng-template>

*ngFor:
<app-server *ngFor="let server of servers; let i = index"></app-server>

Attribute Directives: (change element structure)
----
ngStyle:
<p [ngStyle]="{'background-color': getColor()}"></p>
OR
<p [ngStyle]="{backgroundColor: getColor()}"></p>

ngClass:
<p [ngClass]="{online: serverStatus === 'online'}"></p>    // .online { ... }


Local reference:
---------
.html:
<input type="text" #itemInput>
<button (click)="onItemAdded(itemInput)"></button>

.ts:
onItemAdded(itemInput: HTMLInputElement) {
    console.log(itemInput.value);
}


Viewchild:
------------------------------
.html:
<input type="text" #itemInput>

.ts:
import { ...,  ViewChild, ElementRef} from '@angular/core';
@ViewChild('itemInput') itemInput: ElementRef;
console.log(this.itemInput.nativeElement.value); // use only to read some value, don't write to it

ng-content
----------------------------
child component:
----
.html:
<ng-content></ng-content>

host component:
----
<app-element>
    <p>{{ item.name }}</p> // this gets rendered in the ng-content block
</app-element>


ContentChild
----------------------------
child component:
----
.html:
<ng-content></ng-content>

.ts:
import { ...,  ContentChild, ElementRef} from '@angular/core';
@ContentChild('contentParagraph') contentElement: ElementRef;
console.log(this.itemInput.contentElement.textContent); // use only to read some value, don't write to it

host component:
----
<app-element>
    <p #contentParagraph>{{ item.name }}</p> // this gets rendered in the ng-content block
</app-element>


Component Lifecycle:
-----------------------------------
- ngOnChanges
- ngOnInit
- ngDoCheck
- ngAfterContentInit
- ngAfterContentChecked
- ngAfterViewInit
- ngAfterViewChecked
- ngOnDestroy